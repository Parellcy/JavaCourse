package Sample.MouseOutOfMaze;

public class Main {
    public static void main(String[] args) {
        //老鼠出迷宫
        int[][] maze = new int[8][7];
        //迷宫中，0表示无障碍，1表示障碍物
        //迷宫被障碍物包围
        /*迷宫
              0 1 2 3 4 5 6       //0-6列下标，0-7行下标
            0 1 1 1 1 1 1 1
            1 1           1
            2 1           1
            3 1           1
            4 1           1
            5 1           1
            6 1           1
            7 1 1 1 1 1 1 1
         */
        //迷宫包围圈设置
        for (int i = 0; i < 7; i++) {///固定第一行和第七行，for循环第i列数
            maze[0][i] = 1;//迷宫的最上面一行的障碍物
            maze[7][i] = 1;//迷宫的最下面一行的障碍物
        }
        for (int i = 0; i < 8; i++) {//固定第一列和第七列，for循环第i行数
            maze[i][0] = 1;//迷宫的最左面一行的障碍物
            maze[i][6] = 1;//迷宫的最右面一行的障碍物
        }
        //迷宫障碍物设置（任意）
        maze[3][1] = 1;maze[3][2] = 1;
        //打印地图样式
        System.out.println("==========");
        for (int i = 0; i < maze.length; i++) {
            for (int j = 0; j < maze[i].length; j++) {
                System.out.print(maze[i][j] + " ");
            }
            System.out.println();
        }

        Mouse mouse = new Mouse();
        //打印移动路径（）下 -> 右 -> 上 -> 左
//        System.out.println("==========");
//        mouse.findWay1(maze,1,1);
//        mouse.printWay(maze);

        //打印移动路径（）上 -> 右 -> 下 -> 左
        System.out.println("==========");
        mouse.findWay2(maze,1,1);
        mouse.printWay(maze);



    }
}
/*重！！！所遇困难解决与理解总结
1.在findway1方法中当目的地设置在(6,2)时运行程序，当老鼠到达点(5,4)时就会发现上下左右都为2
    此时并非无解，程序将会把(5,4)设置为3并返回走过的上一个点(5,3)检查是否有可走的路线，
    发现(5,3)无路，设置为3
    ......就这样老鼠会返回到能走的点接着运行
2.老鼠到达目的地的方法（findWay）的本质并非找到能够到达目的地路线，找到路线只是顺手而为，
    本质是从出发点开始，将是无障碍的点全部都走一遍
    只不过在这个过程中设置了约束条件（即达到递归结束循环的点），就结束程序运行
    并在程序运行过程中，每到达一个点，就改变这个点所赋予的含义
    （该含义为：
    0为无障碍，可以走；
    1为有障碍，不可走；
    2为可以走到目的地，是通路；
    3为该路走过但走不通，是死路；)
 */

/*拓展思考：最短路径获取
1.枚举：测试所有可以到达的路径，从中选取中最短路径
2.图：求出最短路径深度优先、广度优先...
 */